Neo4j

> author : yanglulu
>
> date : 2019-06-29

# 1. 简介

## 与RDBMS对比

简单地说，我们可以说图数据库主要用于存储更多的关系数据。

如果我们使用RDBMS数据库来存储更多关系的数据，那么它们不能提供用于遍历大量数据的适当性能。 在这些情况下，Graph Database提高了应用程序性能。

t_user

| id   | name   |
| :--- | ------ |
| 1    | John   |
| 2    | Kate   |
| 3    | Aleksa |
| 4    | Jack   |
| 5    | Jonas  |
| 6    | Anne   |

t_user_friend

| id   | user_1 | user_2 |
| ---- | ------ | ------ |
| 1000 | 1      | 2      |
| 1001 | 3      | 5      |
| 1002 | 4      | 1      |
| 1003 | 6      | 2      |
| 1004 | 4      | 5      |
| 1005 | 1      | 4      |

获取一个特定用户的直接朋友，语句是：

```sql
select count(distinct uf.*) from t_user_friend uf where uf.user_1 = ?
```

查找一个用户的朋友的所有朋友，典型的做法是将表t_user_friend与它自身连接：

```sql
select count(distinct uf2.*) from t_user_friend uf1
inner join t_user_friend uf2 on uf1.user1 = uf2.user_2
where uf1.user_1 = ?
```

社交网络朋友推荐功能，需要找到朋友的朋友的朋友，这时只需要加一个join操作：

```sql
select count(distinct uf3.*) from t_user_friend uf1
inner join t_user_friend uf2 on uf1.user_1 = uf2.user_2
inner join t_user_friend uf3 on uf2.user_1 = uf3.user_2
where uf1.user_1 = ?
```

使用MySQL数据库引擎对一个有1000个用户的数据使用多个join查询的运行时间：

| 深度 | 查询1000个用户的运行时间（秒） | 计数结果 |
| ---- | ------------------------------ | -------- |
| 2    | 0.28                           | ~900     |
| 3    | 0.213                          | ~999     |
| 4    | 10.273                         | ~999     |
| 5    | 92.613                         | ~999     |

Neo4j对一个有1000个用户的图形数据库遍历的运行时间：

| 深度 | 查询1000个用户的运行时间（秒） | 计数结果 |
| ---- | ------------------------------ | -------- |
| 2    | 0.04                           | ~900     |
| 3    | 0.06                           | ~999     |
| 4    | 0.07                           | ~999     |
| 5    | 0.07                           | ~999     |

## Neo4j的特点

- SQL就像简单的查询语言Neo4j CQL
- 它遵循属性图数据模型
- 它通过使用Apache Lucence支持索引
- 它支持UNIQUE约束
- 它包含一个用于执行CQL命令的UI：Neo4j数据浏览器
- 它支持完整的ACID（原子性，一致性，隔离性和持久性）规则
- 它采用原生图形库与本地GPE（图形处理引擎）
- 它支持查询的数据导出到JSON和XLS格式
- 它提供了REST API，可以被任何编程语言（如Java，Spring，Scala等）访问
- 它提供了可以通过任何UI MVC框架（如Node JS）访问的Java脚本
- 它支持两种Java API：Cypher API和Native Java API来开发Java应用程序

## Neo4j的优点

- 它很容易表示连接的数据
- 检索/遍历/导航更多的连接数据是非常容易和快速的
- 它非常容易地表示半结构化数据
- Neo4j CQL查询语言命令是人性化的可读格式，非常容易学习
- 它使用简单而强大的数据模型
- 它不需要复杂的连接来检索连接的/相关的数据，因为它很容易检索它的相邻节点或关系细节没有连接或索引

## Neo4j数据模型

属性图模型规则

- 表示节点，关系和属性中的数据
- 节点和关系都包含属性
- 关系连接节点
- 属性是键值对
- 节点用圆圈表示，关系用方向键表示。
- 关系具有方向：单向和双向。
- 每个关系包含“开始节点”或“从节点”和“到节点”或“结束节点”

图形数据库数据模型的主要构建块是：

- 节点
- 关系
- 属性

------

## Neo4j学习资料

学习教程：https://www.w3cschool.cn/neo4j/

*官网：https://neo4j.com/*

*neo4j中文社区：http://neo4j.com.cn/*

国内下载：<ftp://neo4j.55555.io/neo4j>

*书籍推荐：《Neo4j权威指南》*

# 2. Cypher语句

## CQL简介

CQL代表Cypher查询语言。 像Oracle数据库具有查询语言SQL，Neo4j具有CQL作为查询语言。

- 它是Neo4j图形数据库的查询语言。
- 它是一种声明性模式匹配语言
- 它遵循SQL语法。
- 它的语法是非常简单且人性化、可读的格式。
- Neo4j CQL 以命令来执行数据库操作。
- Neo4j CQL 支持多个子句像在哪里，顺序等，以非常简单的方式编写非常复杂的查询。
- NNeo4j CQL 支持一些功能，如字符串，Aggregation.In 加入他们，它还支持一些关系功能。

## Neo4j CQL数据类型

这些数据类型与Java语言类似。 它们用于定义节点或关系的属性

Neo4j CQL支持以下数据类型：

| S.No. | CQL数据类型 | 用法                            |
| ----- | ----------- | ------------------------------- |
| 1.    | boolean     | 用于表示布尔文字：true，false。 |
| 2.    | byte        | 用于表示8位整数。               |
| 3.    | short       | 用于表示16位整数。              |
| 4.    | int         | 用于表示32位整数。              |
| 5.    | long        | 用于表示64位整数。              |
| 6.    | float       | I用于表示32位浮点数。           |
| 7.    | double      | 用于表示64位浮点数。            |
| 8.    | char        | 用于表示16位字符。              |
| 9.    | String      | 用于表示字符串。                |

## Neo4j CQL常用命令

### 读命令

| S.No. | CQL命令/条        | 用法                                                         |
| ----- | ----------------- | ------------------------------------------------------------ |
| 1.    | MATCH             | 用指定的模式检索数据库                                       |
| 2.    | OPTINAL MATCH     | 用于搜索模式中描述的匹配项，对于找不到的项目用null代替       |
| 3.    | WHERE             | 如果是在WITH和START中，它用于过滤结果，如果用在MATCH和OPTINAL<br/>MATCH，WHERE为模式增加约束条件 |
| 4.    | START             | START语句应当仅用于访问遗留的索引。所有其他的情况，都应使用MATCH代替 |
| 5.    | Aggregation(聚合) | count, sum, avg, stdev, min, max, collect, distinct          |
| 6.    | LOAD CSV          | 用于从CSV文件中导入数据。                                    |

### 写命令

| S.No. | CQL命令/条    | 用法                                                         |
| ----- | ------------- | ------------------------------------------------------------ |
| 1.    | CREATE        | 创建节点，关系和属性                                         |
| 2.    | MERGE         | MERGE可以确保图数据库中存在某个特定的模式。如果该模式不存在，那就创建它。 |
| 3.    | SET           | 用于更新节点的标签以及节点和关系的属性。                     |
| 4.    | DELETE        | 用于删除图元素（节点、关系或路径）                           |
| 5.    | REMOVE        | 用于删除图元素的属性和标签。                                 |
| 6.    | ~~FOREACH~~   | 用于更新列表中的数据，或者来自路径的组件，或者来自聚合的结果。 |
| 7.    | CREATE UNIQUE | 相当于MATCH和CREATE的混合体--尽可能地匹配，然后创建未匹配到的。 |

### 通用命令

| S.No. | CQL命令/条 | 用法                                                         |
| ----- | ---------- | ------------------------------------------------------------ |
| 1.    | RETURN     | RETURN语句定义了查询结果集中返回的内容<br/>RETURN语句有三个子语句，分别为SKIP、LIMIT、ORDER BY。《Neo4j权威指南》page.67 |
| 2.    | ORDER BY   | ORDER BY是紧跟RETURN或者WITH的子句，它指定了输出的结果应该如何排序。<br/>不能对节点或关系进行排序，只能对它们的属性进行排序。 |
| 3.    | LIMIT      | 限制输出的行数。                                             |
| 4.    | SKIP       | 定义了从哪行开始返回结果。                                   |
| 5.    | WITH       | 将分段的查询部分连接在一起，查询结果从一部分以管道形式传递给另一部分作为开始点<br/>用法一：WITH的一个常见用法就是限制传递给其他MATCH语句的结果数。<br/>用法二：另一个用法就是在聚合值上过滤。<br/>用法三：用于将图的读语句和更新语句分开。<br/>（当写部分的语句是基于读语句的结果时，这两者之间的转换必须使用WITH）<br/>当希望使用聚合数据进行过滤时，必须使用WITH将两个读语句部分连接在一起。第一部分做聚合，第二部分过滤来自第一部分的结果。《Neo4j权威指南》page.67 |
| 6.    | ~~UNWIND~~ | 将一个列表展开为一个行的序列。                               |
| 7.    | ~~UNION~~  | 用于将多个查询结果组合起来。                                 |
| 8.    | CALL       | 用于调用数据库中的过程。                                     |

## Neo4j CQL 函数

以下是常用的Neo4j CQL函数：

### 断言(Predicate)函数

| S.No. | 函数     | 用法                                                     |
| ----- | -------- | -------------------------------------------------------- |
| 1.    | all()    | 判断一个断言是否适用于列表中的所有元素                   |
| 2.    | any()    | 判断一个断言至少适用于列表中的一个元素                   |
| 3.    | none()   | 如果断言不适用于列表中的任何元素，则返回true             |
| 4.    | single() | 如果断言刚好只适用于列表中的某一个元素，则返回true       |
| 5.    | exists() | 如果数据库中存在该模式或者节点中存在该属性时，则返回true |

### 标量(Scalar)函数

| S.No. | 函数                  | 用法                                                    |
| ----- | --------------------- | ------------------------------------------------------- |
| 1.    | size()                | 返回表中元素的个数。RETURN size(['A', 'B', 'c']) AS col |
| 2.    | length()              | 返回路径/字符串的长度                                   |
| 3.    | type()                | 返回关系类型                                            |
| 4.    | id()                  | 返回关系或者节点的id                                    |
| 5.    | head()/last()         | 返回列表中的第一个/最后一个元素                         |
| 6.    | timestamp()           | 以毫秒返回当前时间                                      |
| 7.    | startNode()/endNode() | 返回关系的开始/结束节点                                 |
| 8.    | properties()          | 返回节点或者关系的属性map                               |
| 9.    | toInt()/toFloat()     | 将实参转换为一个整数/浮点数                             |

### 列表(List)函数

| S.No.         | 函数            | 用法                     |
| ------------- | --------------- | ------------------------ |
| 1.            | nodes()         | 返回一条路径中的所有节点 |
| 2.            | relationships() | 返回一条路径中的所有关系 |
| ...后面太多了 |                 |                          |

### 数学函数

### 字符串函数

# 3. 与Java交互

## 1). 驱动包开发模式

支持多语言

## 2). JDBC

## 3). REST API

<http://localhost:7474/db/data/node/21>

## 4). Native Java API

## 5). Spring-Data-~~Neo4j~~

# 4. 高级

## ~~分布式~~



